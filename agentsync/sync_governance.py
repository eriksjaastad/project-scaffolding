#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = []
# ///

"""
Governance Document Sync

Copies REVIEWS_AND_GOVERNANCE_PROTOCOL.md from project-scaffolding (SSOT)
to all scaffolded projects. This is a direct replace — no per-project
customization. The source of truth always wins.

A warning header is prepended to synced copies so agents and humans know
the file will be overwritten on the next sync.

Version tracking is written to .scaffolding-version so project-tracker
can surface out-of-sync projects.

Source: project-scaffolding/REVIEWS_AND_GOVERNANCE_PROTOCOL.md
Target: <project>/Documents/REVIEWS_AND_GOVERNANCE_PROTOCOL.md

Usage:
  uv run sync_governance.py                     # Sync all scaffolded projects
  uv run sync_governance.py smart-invoice-workflow  # Sync one project
  uv run sync_governance.py --dry-run           # Show what would change
  uv run sync_governance.py --stage             # Sync and git add changed files
"""

import argparse
import json
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path


SCRIPT_DIR = Path(__file__).resolve().parent
SCAFFOLDING_ROOT = SCRIPT_DIR.parent
PROJECTS_ROOT = SCAFFOLDING_ROOT.parent

SOURCE_FILE = SCAFFOLDING_ROOT / "REVIEWS_AND_GOVERNANCE_PROTOCOL.md"
TARGET_REL = Path("Documents") / "REVIEWS_AND_GOVERNANCE_PROTOCOL.md"

WARNING_HEADER = """\
<!-- ⚠️  DO NOT EDIT THIS FILE ⚠️
     This file is managed by sync_governance.py and will be OVERWRITTEN on the next sync.
     Source of truth: project-scaffolding/REVIEWS_AND_GOVERNANCE_PROTOCOL.md
     To make changes: Edit the source file, then run:
       uv run $PROJECTS_ROOT/project-scaffolding/agentsync/sync_governance.py
     Any local edits WILL BE LOST. -->

"""


def extract_version(source_path: Path) -> str:
    """Extract version from the governance doc title line (e.g., 'v1.3')."""
    first_line = source_path.read_text().split("\n", 1)[0]
    match = re.search(r"\(v([\d.]+)\)", first_line)
    return match.group(1) if match else "0.0.0"


def update_scaffolding_version(project_dir: Path, version: str):
    """Write governance_version and governance_synced_at to .scaffolding-version."""
    version_file = project_dir / ".scaffolding-version"
    try:
        if version_file.exists():
            data = json.loads(version_file.read_text())
        else:
            data = {}

        data["governance_version"] = version
        data["governance_synced_at"] = datetime.now().isoformat()

        version_file.write_text(json.dumps(data, indent=2))
    except Exception as e:
        print(f"  Warning: Failed to update .scaffolding-version: {e}")


def build_synced_content(source_path: Path) -> str:
    """Build the full file content: warning header + source content."""
    return WARNING_HEADER + source_path.read_text()


def find_scaffolded_projects() -> list[Path]:
    """Find all projects with a .scaffolding-version file."""
    projects = []
    for item in sorted(PROJECTS_ROOT.iterdir()):
        if item.is_dir() and (item / ".scaffolding-version").exists():
            # Skip project-scaffolding itself — it has the source, not a copy
            if item.name == "project-scaffolding":
                continue
            projects.append(item)
    return projects


def sync_project(project_dir: Path, version: str, synced_content: str,
                 dry_run: bool = False, stage: bool = False) -> str:
    """
    Sync governance doc to a single project.

    Returns: "updated", "created", or "unchanged"
    """
    target = project_dir / TARGET_REL

    if not target.parent.exists():
        if dry_run:
            return "created"
        target.parent.mkdir(parents=True, exist_ok=True)

    if target.exists():
        if target.read_text() == synced_content:
            return "unchanged"

    if dry_run:
        return "created" if not target.exists() else "updated"

    result = "created" if not target.exists() else "updated"
    target.write_text(synced_content)
    update_scaffolding_version(project_dir, version)

    if stage:
        subprocess.run(
            ["git", "add", str(target)],
            cwd=project_dir,
            capture_output=True,
        )

    return result


def main():
    parser = argparse.ArgumentParser(description="Sync governance doc to scaffolded projects")
    parser.add_argument("project", nargs="?", help="Specific project name (default: all)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would change")
    parser.add_argument("--stage", action="store_true", help="Git add changed files")
    args = parser.parse_args()

    if not SOURCE_FILE.exists():
        print(f"Error: Source not found at {SOURCE_FILE}")
        sys.exit(1)

    version = extract_version(SOURCE_FILE)
    synced_content = build_synced_content(SOURCE_FILE)
    print(f"Governance Protocol v{version}")

    if args.project:
        project_dir = PROJECTS_ROOT / args.project
        if not project_dir.exists():
            print(f"Error: Project not found: {project_dir}")
            sys.exit(1)
        projects = [project_dir]
    else:
        projects = find_scaffolded_projects()

    if args.dry_run:
        print("DRY RUN — no files will be changed\n")

    counts = {"updated": 0, "created": 0, "unchanged": 0}

    for project_dir in projects:
        result = sync_project(project_dir, version, synced_content,
                              dry_run=args.dry_run, stage=args.stage)
        counts[result] = counts.get(result, 0) + 1

        if result == "unchanged":
            continue

        icon = {"updated": "\u270f\ufe0f ", "created": "\u2728"}.get(result, "  ")
        print(f"  {icon} {project_dir.name}: {result}")

    print(f"\nDone: {counts['updated']} updated, {counts['created']} created, {counts['unchanged']} unchanged")


if __name__ == "__main__":
    main()
